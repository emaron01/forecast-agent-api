{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/maron/Documents/forecast-agent-api/web/app/api/agent/sessions.ts"],"sourcesContent":["// Shared sessions storage - persists across hot reloads\n// Using a global variable to avoid Next.js module reload issues\n\ndeclare global {\n  // eslint-disable-next-line no-var\n  var __sessions__: Map<\n    string,\n    {\n      orgId: number;\n      repName: string;\n      deals: any[];\n      index: number;\n      scoreDefs: any[];\n      touched: Set<string>;\n      // Running Responses API item list (messages + tool calls + tool outputs).\n      items: any[];\n      // End-of-deal wrap must be saved for current deal before advancing.\n      wrapSaved: boolean;\n    }\n  > | undefined;\n}\n\n// Use existing global or create new Map\nconst sessions =\n  global.__sessions__ ||\n  (global.__sessions__ = new Map<\n    string,\n    {\n      orgId: number;\n      repName: string;\n      deals: any[];\n      index: number;\n      scoreDefs: any[];\n      touched: Set<string>;\n      items: any[];\n      wrapSaved: boolean;\n    }\n  >());\n\nexport { sessions };\n"],"names":[],"mappings":"AAAA,wDAAwD;AACxD,gEAAgE;;;;;AAqBhE,wCAAwC;AACxC,MAAM,WACJ,OAAO,YAAY,IACnB,CAAC,OAAO,YAAY,GAAG,IAAI,KAYxB"}},
    {"offset": {"line": 59, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/maron/Documents/forecast-agent-api/web/lib/prompt.ts"],"sourcesContent":["type Deal = Record<string, any>;\ntype ScoreDef = { category: string; score: number; label?: string; criteria?: string };\n\nfunction formatScoreDefinitions(defs: ScoreDef[]) {\n  if (!Array.isArray(defs) || defs.length === 0) return \"No criteria available.\";\n  const byCat = new Map<string, ScoreDef[]>();\n  for (const row of defs) {\n    const cat = row.category || \"unknown\";\n    if (!byCat.has(cat)) byCat.set(cat, []);\n    byCat.get(cat)!.push(row);\n  }\n  const lines: string[] = [];\n  for (const [cat, rows] of byCat.entries()) {\n    rows.sort((a, b) => Number(a.score) - Number(b.score));\n    lines.push(`${cat.toUpperCase()}:`);\n    for (const r of rows) {\n      lines.push(`- ${r.score}: ${r.label || \"\"} — ${r.criteria || \"\"}`);\n    }\n  }\n  return lines.join(\"\\n\");\n}\n\nfunction buildLabelMap(defs: ScoreDef[]) {\n  const map: Record<string, Record<number, string>> = {};\n  for (const row of defs || []) {\n    const cat = row.category;\n    if (!cat) continue;\n    if (!map[cat]) map[cat] = {};\n    map[cat][Number(row.score)] = row.label || \"\";\n  }\n  return map;\n}\n\nfunction computeFirstGap(deal: Deal, stage: string, touchedSet?: Set<string>) {\n  const stageStr = String(stage || deal?.forecast_stage || \"Pipeline\");\n  const pipelineOrder = [\n    { name: \"Pain\", key: \"pain_score\", val: deal.pain_score, touchedKey: \"pain\" },\n    { name: \"Metrics\", key: \"metrics_score\", val: deal.metrics_score, touchedKey: \"metrics\" },\n    { name: \"Internal Sponsor\", key: \"champion_score\", val: deal.champion_score, touchedKey: \"champion\" },\n    { name: \"Competition\", key: \"competition_score\", val: deal.competition_score, touchedKey: \"competition\" },\n    { name: \"Budget\", key: \"budget_score\", val: deal.budget_score, touchedKey: \"budget\" },\n  ];\n  const bestCaseCommitOrder = [\n    { name: \"Pain\", key: \"pain_score\", val: deal.pain_score, touchedKey: \"pain\" },\n    { name: \"Metrics\", key: \"metrics_score\", val: deal.metrics_score, touchedKey: \"metrics\" },\n    { name: \"Internal Sponsor\", key: \"champion_score\", val: deal.champion_score, touchedKey: \"champion\" },\n    { name: \"Criteria\", key: \"criteria_score\", val: deal.criteria_score, touchedKey: \"criteria\" },\n    { name: \"Competition\", key: \"competition_score\", val: deal.competition_score, touchedKey: \"competition\" },\n    { name: \"Timing\", key: \"timing_score\", val: deal.timing_score, touchedKey: \"timing\" },\n    { name: \"Budget\", key: \"budget_score\", val: deal.budget_score, touchedKey: \"budget\" },\n    { name: \"Economic Buyer\", key: \"eb_score\", val: deal.eb_score, touchedKey: \"eb\" },\n    { name: \"Decision Process\", key: \"process_score\", val: deal.process_score, touchedKey: \"process\" },\n    { name: \"Paper Process\", key: \"paper_score\", val: deal.paper_score, touchedKey: \"paper\" },\n  ];\n  const order = stageStr.includes(\"Commit\") || stageStr.includes(\"Best Case\")\n    ? bestCaseCommitOrder\n    : pipelineOrder;\n\n  if (touchedSet && touchedSet.size > 0) {\n    const nextUntouched = order.find((s) => !touchedSet.has(s.touchedKey));\n    if (nextUntouched) return nextUntouched;\n  }\n  return order[0];\n}\n\nexport function buildPrompt(deal: Deal, repName: string, totalCount: number, isFirstDeal: boolean, touchedSet: Set<string>, scoreDefs: ScoreDef[]) {\n  const stage = deal.forecast_stage || \"Pipeline\";\n  const amountStr = new Intl.NumberFormat(\"en-US\", {\n    style: \"currency\",\n    currency: \"USD\",\n    maximumFractionDigits: 0,\n  }).format(Number(deal.amount || 0));\n  const closeDateStr = deal.close_date ? new Date(deal.close_date).toLocaleDateString() : \"TBD\";\n  const oppName = (deal.opportunity_name || \"\").trim();\n  const oppNamePart = oppName ? ` — ${oppName}` : \"\";\n\n  const callPickup =\n    `Hi ${repName}, this is Matthew from Sales Forecaster. ` +\n    `Today we are reviewing ${totalCount} deals. ` +\n    `Let's jump in starting with ${deal.account_name}${oppNamePart} ` +\n    `for ${amountStr} in CRM Forecast Stage ${stage} closing ${closeDateStr}.`;\n\n  const dealOpening =\n    `Let’s look at ${deal.account_name}${oppNamePart}, ` +\n    `${stage}, ${amountStr}, closing ${closeDateStr}.`;\n\n  const riskRecall = deal.risk_summary\n    ? `Existing Risk Summary: ${deal.risk_summary}`\n    : \"No prior risk summary recorded.\";\n\n  const firstGap = computeFirstGap(deal, stage, touchedSet);\n  const labelMap = buildLabelMap(scoreDefs);\n  const labelKeyMap: Record<string, string> = {\n    pain_score: \"pain\",\n    metrics_score: \"metrics\",\n    champion_score: \"champion\",\n    criteria_score: \"criteria\",\n    competition_score: \"competition\",\n    timing_score: \"timing\",\n    budget_score: \"budget\",\n    eb_score: \"economic_buyer\",\n    process_score: \"process\",\n    paper_score: \"paper\",\n  };\n  const scoreVal = Number(deal?.[firstGap.key] ?? 0);\n  const labelCategory = labelKeyMap[firstGap.key] || \"\";\n  const label = (labelCategory && labelMap[labelCategory]?.[scoreVal]) || \"Unknown\";\n\n  const gapQuestion = (() => {\n    if (scoreVal >= 3) {\n      return `Last review ${firstGap.name} was strong. Has anything changed that could introduce new risk?`;\n    }\n    if (scoreVal === 0) {\n      if (String(stage).includes(\"Pipeline\")) {\n        if (firstGap.name === \"Pain\")\n          return \"What specific business problem is the customer trying to solve, and what happens if they do nothing?\";\n        if (firstGap.name === \"Metrics\")\n          return \"What measurable outcome has the customer agreed matters, and who validated it?\";\n        if (firstGap.name === \"Internal Sponsor\")\n          return \"Who is driving this internally, what is their role, and how have they shown advocacy?\";\n        if (firstGap.name === \"Budget\")\n          return \"Has budget been discussed or confirmed, and at what level?\";\n        return `What changed since last time on ${firstGap.name}?`;\n      }\n      return `What is the latest on ${firstGap.name}?`;\n    }\n    return `Last review ${firstGap.name} was ${label}. Have we made progress since the last review?`;\n  })();\n\n  const firstLine = isFirstDeal ? callPickup : dealOpening;\n  const criteriaBlock = formatScoreDefinitions(scoreDefs);\n\n  return `\nSYSTEM PROMPT — SALES FORECAST AGENT\nYou are a Sales Forecast Agent applying MEDDPICC + Timing + Budget to sales opportunities.\nYour job is to run fast, rigorous deal reviews that the rep can be honest in.\n\nNON-NEGOTIABLES\n- Speak only English. Do not switch languages.\n- Do NOT invent facts. Never assume answers that were not stated by the rep.\n- Do NOT reveal category scores, scoring logic, scoring matrix, or how a category is computed.\n- Do NOT speak coaching tips, category summaries, or \"what I heard.\" Coaching and summaries are allowed ONLY in the written fields that will be saved (e.g., *_summary, *_tip, risk_summary, next_steps).\n- Use concise spoken language. Keep momentum. No dead air after saves—always ask the next question.\n- Never use the word \"champion.\" Use \"internal sponsor\" or \"coach\" instead.\n\nHARD CONTEXT (NON-NEGOTIABLE)\nYou are reviewing exactly:\n- DEAL_ID: ${deal.id}\n- ACCOUNT_NAME: ${deal.account_name}\n- OPPORTUNITY_NAME: ${oppName || \"(none)\"}\n- STAGE: ${stage}\nNever change deal identity unless the rep explicitly corrects it.\n\nDEAL INTRO (spoken)\nAt the start of this deal, you may speak ONLY:\n1) \"${firstLine}\"\n2) \"${riskRecall}\"\nThen immediately ask the first category question: \"${gapQuestion}\"\n\nCATEGORY ORDER (strict)\nPipeline deals (strict order):\n1) Pain\n2) Metrics\n3) Internal Sponsor (do NOT say champion)\n4) Competition\n5) Budget\n\nBest Case / Commit deals (strict order):\n1) Pain\n2) Metrics\n3) Internal Sponsor\n4) Criteria\n5) Competition\n6) Timing\n7) Budget\n8) Economic Buyer\n9) Decision Process\n10) Paper Process\n\nRules:\n- Never skip ahead.\n- Never reorder.\n- Never revisit a category unless the rep introduces NEW information for that category.\n\nQUESTIONING RULES (spoken)\n- Exactly ONE primary question per category.\n- At most ONE clarification question if the answer is vague or incomplete.\n- No spoken summaries. No spoken coaching. No repeating the rep's answer back.\n- After capturing enough info, proceed: silently update fields and save, then immediately ask the next category question.\n\nSCORING / WRITTEN OUTPUT RULES (silent)\nFor each category you touch:\n- Update the category score (integer) consistent with your scoring definitions.\n- Update label/summary/tip ONLY in the dedicated fields for that category (e.g., pain_summary, pain_tip, etc.).\n- If no meaningful coaching tip is needed, leave the tip blank (do not invent filler).\n- Be skeptical by default. You are an auditor, not a cheerleader.\n- Only give a 3 when the rep provides concrete, current-cycle evidence that fully meets the definition.\n- If evidence is vague, aspirational, or second‑hand, score lower and explain the gap in the summary/tip.\n- Favor truth over momentum: it is better to downgrade than to accept weak proof.\n- MEDDPICC rigor is mandatory: a named person ≠ a Champion, and a stated metric ≠ validated Metrics.\n- Champion (Internal Sponsor) requires: power/influence, active advocacy, and a concrete action they drove in this cycle.\n- Metrics require: measurable outcome, baseline + target, and buyer validation (not just rep belief).\n\nSCORING CRITERIA (AUTHORITATIVE)\nUse these exact definitions as the litmus test for labels and scores:\n${criteriaBlock}\n\nIMPORTANT:\nThe criteria are ONLY for scoring. Do NOT ask extra questions beyond the ONE allowed clarification.\n\nUnknowns:\n- If the rep explicitly says it's unknown or not applicable, score accordingly (typically 0/Unknown) and write a short summary reflecting that.\n\nCATEGORY CHECK PATTERNS (spoken)\n- For categories with prior score >= 3:\n  Say: \"Last review <Category> was strong. Has anything changed that could introduce new risk?\"\n  If rep says \"NO\" or \"nothing changed\": say \"Got it.\" and move to next category WITHOUT saving.\n  If rep provides ANY other answer: ask ONE follow-up if needed, then SAVE with updated score/summary/tip (upgrade or downgrade based on evidence).\n\n- For categories with prior score 1 or 2:\n  MUST ASK THIS WAY: \"Last review <Category> was <Label>. Have we made progress since the last review?\"\n  If clear improvement: capture evidence, rescore upward, silently update label/summary/coaching tip, save.\n  If degradation (worse): capture evidence, rescore downward, silently update label/summary/coaching tip, save.\n  If unclear/vague: ask ONE challenging follow-up (accuracy > speed).\n  If no change / unchanged / no / no progress / etc.: confirm, then move on WITHOUT saving.\n  CRITICAL: Preserve existing summaries/tips when no change is reported. Do NOT overwrite good detail with empty or less detailed content.\n\n- For categories with prior score 0 (or empty):\n  Treat as \"not previously established.\"\n  Do NOT say \"last review was…\" or reference any prior state.\n  Ask the primary question directly.\n  ALWAYS SAVE after the rep answers.\n\nDEGRADATION (silent)\nAny category may drop (including 3 → 0) if evidence supports it. No score protection. Truth > momentum.\nIf degradation happens: capture the new risk, rescore downward, silently update summary/tip, save.\n\nCROSS-CATEGORY ANSWERS\nIf the rep provides info that answers a future category while answering the current one:\n- Silently extract it and store it for that future category.\n- When you reach that category later, do NOT re-ask; say only:\n  \"I already captured that earlier based on your previous answer.\"\nThen proceed to the next category.\n\nMANDATORY WORKFLOW (NON-NEGOTIABLE)\nAfter each rep answer:\n1) Say: \"Got it.\" (brief acknowledgment)\n2) If a save is required, call save_deal_data silently with score/summary/tip.\n3) Then immediately ask the next category question.\nNo spoken summaries or coaching.\n\nCRITICAL RULES:\n- Tool calls are 100% silent - never mention saving or updating\n- Follow the category check patterns exactly for when to save vs move on\n- If the rep says \"I don't know\" or provides weak evidence, still save with a low score (0-1)\n\nHEALTH SCORE (spoken only at end)\n- Health Score is ALWAYS out of 30 and is COMPUTED BY THE SYSTEM from category scores.\n- You must NEVER invent or guess the number. A system message will give you the exact score to say when it is time for the end-of-deal wrap; use that number exactly.\n- Never change the denominator. Never reveal individual category scores.\n- If asked how it was calculated: \"Your score is based on the completeness and strength of your MEDDPICC answers.\"\n\nEND-OF-DEAL WRAP (spoken + save — BOTH steps required)\nAfter all required categories for the deal type are reviewed:\n1. Synthesize an Updated Risk Summary and Suggested Next Steps based on everything discussed.\n2. Speak the wrap in this exact order:\n   a) \"Updated Risk Summary: <your synthesized risk summary>\"\n   b) Say: \"Your Deal Health Score is X out of 30.\" (X will be provided in a system message — use it exactly; do not make up a number)\n   c) \"Suggested Next Steps: <your recommended next steps>\"\n3. IMMEDIATELY call save_deal_data with NON-EMPTY text for BOTH:\n   - risk_summary: the exact risk summary you just spoke (required; saves the END summary)\n   - next_steps: the exact next steps you just spoke (required; saves the END next steps)\n   Do NOT include any score fields in this save. Do NOT call advance_deal until you have called save_deal_data with both risk_summary and next_steps.\n4. THEN call advance_deal tool silently.\n\nDo NOT ask for rep confirmation. Do NOT invite edits.\n`.trim();\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 392, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/maron/Documents/forecast-agent-api/web/lib/tools.ts"],"sourcesContent":["export function buildTools() {\n  const scoreInt = { type: \"integer\", minimum: 0, maximum: 3 };\n  return [\n    {\n      type: \"function\",\n      name: \"save_deal_data\",\n      description:\n        \"REQUIRED after EVERY rep answer. Save the score (0-3), summary, and coaching tip for the category you just asked about.\",\n      parameters: {\n        type: \"object\",\n        properties: {\n          pain_score: scoreInt,\n          pain_summary: { type: \"string\" },\n          pain_tip: { type: \"string\" },\n          metrics_score: scoreInt,\n          metrics_summary: { type: \"string\" },\n          metrics_tip: { type: \"string\" },\n          champion_score: scoreInt,\n          champion_summary: { type: \"string\" },\n          champion_tip: { type: \"string\" },\n          champion_name: { type: \"string\" },\n          champion_title: { type: \"string\" },\n          eb_score: scoreInt,\n          eb_summary: { type: \"string\" },\n          eb_tip: { type: \"string\" },\n          eb_name: { type: \"string\" },\n          eb_title: { type: \"string\" },\n          criteria_score: scoreInt,\n          criteria_summary: { type: \"string\" },\n          criteria_tip: { type: \"string\" },\n          process_score: scoreInt,\n          process_summary: { type: \"string\" },\n          process_tip: { type: \"string\" },\n          competition_score: scoreInt,\n          competition_summary: { type: \"string\" },\n          competition_tip: { type: \"string\" },\n          paper_score: scoreInt,\n          paper_summary: { type: \"string\" },\n          paper_tip: { type: \"string\" },\n          timing_score: scoreInt,\n          timing_summary: { type: \"string\" },\n          timing_tip: { type: \"string\" },\n          budget_score: scoreInt,\n          budget_summary: { type: \"string\" },\n          budget_tip: { type: \"string\" },\n          risk_summary: { type: \"string\" },\n          next_steps: { type: \"string\" },\n          rep_comments: { type: \"string\" },\n        },\n        required: [],\n      },\n      // Keep non-strict to match current behavior (optional fields).\n      strict: false,\n    },\n    {\n      type: \"function\",\n      name: \"advance_deal\",\n      description: \"Advance to the next deal after end-of-deal wrap.\",\n      parameters: { type: \"object\", properties: {} },\n      strict: false,\n    },\n  ];\n}\n\n"],"names":[],"mappings":";;;;AAAO,SAAS;IACd,MAAM,WAAW;QAAE,MAAM;QAAW,SAAS;QAAG,SAAS;IAAE;IAC3D,OAAO;QACL;YACE,MAAM;YACN,MAAM;YACN,aACE;YACF,YAAY;gBACV,MAAM;gBACN,YAAY;oBACV,YAAY;oBACZ,cAAc;wBAAE,MAAM;oBAAS;oBAC/B,UAAU;wBAAE,MAAM;oBAAS;oBAC3B,eAAe;oBACf,iBAAiB;wBAAE,MAAM;oBAAS;oBAClC,aAAa;wBAAE,MAAM;oBAAS;oBAC9B,gBAAgB;oBAChB,kBAAkB;wBAAE,MAAM;oBAAS;oBACnC,cAAc;wBAAE,MAAM;oBAAS;oBAC/B,eAAe;wBAAE,MAAM;oBAAS;oBAChC,gBAAgB;wBAAE,MAAM;oBAAS;oBACjC,UAAU;oBACV,YAAY;wBAAE,MAAM;oBAAS;oBAC7B,QAAQ;wBAAE,MAAM;oBAAS;oBACzB,SAAS;wBAAE,MAAM;oBAAS;oBAC1B,UAAU;wBAAE,MAAM;oBAAS;oBAC3B,gBAAgB;oBAChB,kBAAkB;wBAAE,MAAM;oBAAS;oBACnC,cAAc;wBAAE,MAAM;oBAAS;oBAC/B,eAAe;oBACf,iBAAiB;wBAAE,MAAM;oBAAS;oBAClC,aAAa;wBAAE,MAAM;oBAAS;oBAC9B,mBAAmB;oBACnB,qBAAqB;wBAAE,MAAM;oBAAS;oBACtC,iBAAiB;wBAAE,MAAM;oBAAS;oBAClC,aAAa;oBACb,eAAe;wBAAE,MAAM;oBAAS;oBAChC,WAAW;wBAAE,MAAM;oBAAS;oBAC5B,cAAc;oBACd,gBAAgB;wBAAE,MAAM;oBAAS;oBACjC,YAAY;wBAAE,MAAM;oBAAS;oBAC7B,cAAc;oBACd,gBAAgB;wBAAE,MAAM;oBAAS;oBACjC,YAAY;wBAAE,MAAM;oBAAS;oBAC7B,cAAc;wBAAE,MAAM;oBAAS;oBAC/B,YAAY;wBAAE,MAAM;oBAAS;oBAC7B,cAAc;wBAAE,MAAM;oBAAS;gBACjC;gBACA,UAAU,EAAE;YACd;YACA,+DAA+D;YAC/D,QAAQ;QACV;QACA;YACE,MAAM;YACN,MAAM;YACN,aAAa;YACb,YAAY;gBAAE,MAAM;gBAAU,YAAY,CAAC;YAAE;YAC7C,QAAQ;QACV;KACD;AACH"}},
    {"offset": {"line": 523, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/maron/Documents/forecast-agent-api/muscle.js"],"sourcesContent":["/**\n * muscle.js\n * - Core tool handler for saving category data, auditing, and light deal state updates.\n * - MUST export handleFunctionCall as a named export.\n */\n\nfunction nowIso() {\n  return new Date().toISOString();\n}\n\nfunction cleanText(v) {\n  if (v == null) return null;\n  const s = String(v).trim();\n  return s.length ? s : null;\n}\n\nfunction vpTipForCategory(category) {\n  const tips = {\n    pain:\n      \"Quantify the business impact, clarify who feels it most, and tie it to a deadline the buyer owns.\",\n    metrics:\n      \"Define one measurable outcome with a baseline and target, and get the buyer to confirm it in writing.\",\n    champion:\n      \"Confirm the internal sponsor’s influence and actions this cycle, and secure a concrete next step they will drive.\",\n    competition:\n      \"Document the competitive alternative and your differentiation in the buyer’s words, then validate it with the sponsor.\",\n    budget:\n      \"Identify the funding source, approval path, and exact amount required; secure the approver’s acknowledgement.\",\n    criteria:\n      \"Get the decision criteria prioritized by the buyer and map how you meet the top two in their language.\",\n    process:\n      \"Map the decision process step‑by‑step, owners and dates, and validate where the deal can stall.\",\n    paper:\n      \"Confirm contracting steps, legal review owner, and the earliest signature date the buyer will commit to.\",\n    timing:\n      \"Anchor the close to a buyer‑owned event and validate the critical path milestones to reach it.\",\n    eb:\n      \"Identify the economic buyer, confirm their priorities, and secure direct access or a committed intro.\",\n  };\n  return tips[category] || \"Validate the critical evidence and confirm ownership for this category.\";\n}\n\nasync function getScoreLabel(pool, orgId, category, score) {\n  if (!category || score == null) return null;\n  const { rows } = await pool.query(\n    `\n    SELECT label\n      FROM score_definitions\n     WHERE org_id = $1\n       AND category = $2\n       AND score = $3\n     LIMIT 1\n    `,\n    [orgId, category, score]\n  );\n  return rows[0]?.label ?? null;\n}\n\n/**\n * Detect which category is being saved from tool args.\n * We store <category>_score, <category>_summary, <category>_tip.\n */\nfunction detectCategoryFromArgs(args) {\n  const keys = Object.keys(args || {});\n  const scoreKey = keys.find((k) => k.endsWith(\"_score\"));\n  if (!scoreKey) return null;\n  return scoreKey.replace(/_score$/, \"\");\n}\n\n/**\n * Build a \"delta\" JSON payload for opportunity_audit_events.\n * Keep it compact: only store fields the tool provided for this save.\n */\nfunction buildDelta(args) {\n  const out = {};\n  for (const [k, v] of Object.entries(args || {})) {\n    if (k === \"org_id\" || k === \"opportunity_id\" || k === \"rep_name\" || k === \"call_id\") continue;\n    out[k] = v;\n  }\n  return out;\n}\n\n/**\n * Compute running total score/max score if present in opportunity row\n * (kept minimal: muscle does not invent weights; server/db own scoring tables).\n */\nasync function recomputeTotalScore(pool, orgId, opportunityId) {\n  // Keep your existing schema assumptions: category columns end in _score\n  // We'll sum whatever exists for MEDDPICC+TB (safe generic).\n  const { rows } = await pool.query(\n    `SELECT *\n       FROM opportunities\n      WHERE org_id = $1 AND id = $2\n      LIMIT 1`,\n    [orgId, opportunityId]\n  );\n  if (!rows.length) return { total_score: null, max_score: null };\n\n  const row = rows[0];\n  let total = 0;\n  let hasAny = false;\n\n  for (const [k, v] of Object.entries(row)) {\n    if (!k.endsWith(\"_score\")) continue;\n    if (typeof v !== \"number\") continue;\n    total += v;\n    hasAny = true;\n  }\n\n  // max_score depends on what categories exist; keep null if unknown.\n  return { total_score: hasAny ? total : null, max_score: null };\n}\n\n/**\n * Insert audit event row.\n */\nasync function insertAuditEvent(pool, {\n  orgId,\n  opportunityId,\n  actorType,\n  eventType,\n  forecastStage,\n  aiForecast,\n  totalScore,\n  maxScore,\n  riskSummary,\n  riskFlags,\n  delta,\n  definitions,\n  meta,\n  runId,\n  callId,\n  schemaVersion = 1,\n  promptVersion = \"v1\",\n  logicVersion = \"v1\",\n}) {\n  const q = `\n    INSERT INTO opportunity_audit_events\n      (org_id, opportunity_id, actor_type, event_type, schema_version, prompt_version, logic_version,\n       forecast_stage, ai_forecast, total_score, max_score, risk_summary, risk_flags, delta, definitions, meta, run_id, call_id)\n    VALUES\n      ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14::jsonb,$15::jsonb,$16::jsonb,$17,$18)\n    RETURNING id\n  `;\n\n  const { rows } = await pool.query(q, [\n    orgId,\n    opportunityId,\n    actorType,\n    eventType,\n    schemaVersion,\n    promptVersion,\n    logicVersion,\n    forecastStage,\n    aiForecast,\n    totalScore,\n    maxScore,\n    riskSummary,\n    riskFlags,\n    JSON.stringify(delta || {}),\n    JSON.stringify(definitions || {}),\n    JSON.stringify(meta || {}),\n    runId,\n    callId,\n  ]);\n\n  return rows[0]?.id ?? null;\n}\n\n/**\n * Main tool handler (named export)\n */\nexport async function handleFunctionCall({ toolName, args, pool }) {\n  if (toolName !== \"save_deal_data\") {\n    return { ok: true, ignored: toolName };\n  }\n\n  const orgId = Number(args.org_id);\n  const opportunityId = Number(args.opportunity_id);\n  if (!orgId || !opportunityId) {\n    throw new Error(\"save_deal_data requires org_id and opportunity_id\");\n  }\n\n  const repName = cleanText(args.rep_name);\n  const callId = cleanText(args.call_id);\n\n  // Normalize common camelCase variants (models sometimes emit these).\n  // DB columns and the rest of the app expect snake_case.\n  if (args && args.risk_summary == null && args.riskSummary != null) {\n    args.risk_summary = args.riskSummary;\n  }\n  if (args && args.next_steps == null && args.nextSteps != null) {\n    args.next_steps = args.nextSteps;\n  }\n\n  const category = detectCategoryFromArgs(args);\n  const delta = buildDelta(args);\n\n  // Enforce: summary saved as \"Label: <summary>\" and always write *_tip key.\n  // This makes saved data consistent even if the model omits label/tip.\n  if (category) {\n    const scoreKey = `${category}_score`;\n    const summaryKey = `${category}_summary`;\n    const tipKey = `${category}_tip`;\n\n    const scoreVal = args?.[scoreKey];\n    const scoreNum = Number(scoreVal);\n    const hasScore = Number.isFinite(scoreNum);\n\n    // Ensure tip key exists so DB column is written (can be empty string)\n    if (args?.[tipKey] === undefined || args?.[tipKey] == null) args[tipKey] = \"\";\n\n    if (hasScore && args?.[summaryKey] != null) {\n      const rawSummary = cleanText(args[summaryKey]);\n      if (rawSummary) {\n        const label = await getScoreLabel(pool, orgId, category, scoreNum);\n        if (label) {\n          const prefix = `${label}:`;\n          args[summaryKey] = rawSummary.startsWith(prefix)\n            ? rawSummary\n            : `${label}: ${rawSummary}`;\n        } else {\n          // If no label definition exists, still keep the summary clean.\n          args[summaryKey] = rawSummary;\n        }\n      }\n    }\n\n    // If tip is missing/blank, generate a minimal deterministic coaching tip\n    // without inventing facts.\n    const cleanedTip = cleanText(args[tipKey]);\n    if (!cleanedTip) {\n      if (hasScore && scoreNum >= 3) {\n        args[tipKey] = `Maintain current evidence; monitor for changes in ${category}.`;\n      } else if (hasScore) {\n        args[tipKey] = vpTipForCategory(category);\n      } else {\n        args[tipKey] = vpTipForCategory(category);\n      }\n    }\n  }\n\n  // Update opportunity columns that are present in args (score/summary/tip + optional extras)\n  // Only allow known patterns: *_score, *_summary, *_tip, *_name, *_title, etc.\n  const allowed = Object.keys(args).filter((k) =>\n    /_(score|summary|tip|name|title|source|notes)$/.test(k)\n  );\n  // Avoid double-assigning special summary fields handled below.\n  const safeAllowed = allowed.filter((k) => k !== \"risk_summary\" && k !== \"next_steps\");\n\n  const sets = [];\n  const vals = [];\n  let i = 2;\n\n  for (const k of safeAllowed) {\n    // Prevent wiping summaries with empty strings\n    if (k.endsWith(\"_summary\")) {\n      const cleaned = cleanText(args[k]);\n      if (!cleaned) continue;\n      args[k] = cleaned;\n    }\n    // Always persist tip (empty allowed) to satisfy required output\n    if (k.endsWith(\"_tip\") && args[k] == null) {\n      args[k] = \"\";\n    }\n    sets.push(`${k} = $${++i}`);\n    vals.push(args[k]);\n  }\n\n  // Also update risk_summary/next_steps if provided by tool (only persist non-empty to avoid wiping).\n  const riskSummaryCleaned = cleanText(args.risk_summary);\n  if (riskSummaryCleaned) {\n    sets.push(`risk_summary = $${++i}`);\n    vals.push(riskSummaryCleaned);\n  }\n  const nextStepsCleaned = cleanText(args.next_steps);\n  if (nextStepsCleaned) {\n    sets.push(`next_steps = $${++i}`);\n    vals.push(nextStepsCleaned);\n  }\n\n  // Always stamp updated_at if exists\n  sets.push(`updated_at = NOW()`);\n\n  // Start transaction\n  const client = await pool.connect();\n  try {\n    await client.query(\"BEGIN\");\n\n    if (sets.length) {\n      const q = `\n        UPDATE opportunities\n           SET ${sets.join(\", \")}\n         WHERE org_id = $1\n           AND id = $2\n      `;\n      await client.query(q, [orgId, opportunityId, ...vals]);\n    }\n\n    // Pull latest opp row for audit context fields\n    const { rows } = await client.query(\n      `SELECT id, org_id, forecast_stage, ai_forecast, health_score, risk_summary\n         FROM opportunities\n        WHERE org_id = $1 AND id = $2\n        LIMIT 1`,\n      [orgId, opportunityId]\n    );\n\n    const opp = rows[0] || {};\n    const recomputed = await recomputeTotalScore(client, orgId, opportunityId);\n\n    // Persist computed health_score so the agent always has a real number to speak (never invent).\n    if (recomputed.total_score != null && Number.isFinite(recomputed.total_score)) {\n      await client.query(\n        `UPDATE opportunities SET health_score = $3, updated_at = NOW() WHERE org_id = $1 AND id = $2`,\n        [orgId, opportunityId, recomputed.total_score]\n      );\n    }\n\n    // Create audit event (compact delta)\n    const runId = args.run_id || null; // if you pass it later\n    const auditId = await insertAuditEvent(client, {\n      orgId,\n      opportunityId,\n      actorType: \"agent\",\n      eventType: \"score_save\",\n      forecastStage: opp.forecast_stage ?? null,\n      aiForecast: opp.ai_forecast ?? null,\n      totalScore: opp.health_score ?? null,\n      maxScore: 30,\n      riskSummary: opp.risk_summary ?? null,\n      riskFlags: args.risk_flags ?? null,\n      delta,\n      definitions: args.definitions ?? null,\n      meta: {\n        rep_name: repName,\n        category,\n        saved_at: nowIso(),\n      },\n      runId: runId || cryptoRandomUUIDSafe(),\n      callId,\n      schemaVersion: 1,\n      promptVersion: args.prompt_version || \"v1\",\n      logicVersion: args.logic_version || \"v1\",\n    });\n\n    await client.query(\"COMMIT\");\n\n    return {\n      ok: true,\n      saved: true,\n      opportunity_id: opportunityId,\n      audit_event_id: auditId,\n    };\n  } catch (e) {\n    await client.query(\"ROLLBACK\");\n    throw e;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Safe UUID if crypto.randomUUID exists; otherwise null-ish.\n */\nfunction cryptoRandomUUIDSafe() {\n  try {\n    // Node 18+ supports global crypto.randomUUID in many runtimes\n    // but not all; guard it.\n    // eslint-disable-next-line no-undef\n    if (globalThis.crypto && typeof globalThis.crypto.randomUUID === \"function\") {\n      // eslint-disable-next-line no-undef\n      return globalThis.crypto.randomUUID();\n    }\n  } catch {}\n  // fallback: pseudo\n  return `run_${Date.now()}_${Math.random().toString(16).slice(2)}`;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 847, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/maron/Documents/forecast-agent-api/web/app/api/respond/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport { Pool } from \"pg\";\nimport { sessions } from \"../agent/sessions\";\nimport { buildPrompt } from \"../../../lib/prompt\";\nimport { buildTools } from \"../../../lib/tools\";\nimport { handleFunctionCall } from \"../../../../muscle.js\";\n\nexport const runtime = \"nodejs\";\n\nfunction resolveBaseUrl() {\n  const raw = (process.env.OPENAI_BASE_URL || process.env.MODEL_API_URL || \"\").trim();\n  if (!raw) return \"\";\n  // Allow re-using old Realtime URLs (wss://.../v1/realtime) by converting them.\n  const wsNormalized = raw.replace(/^wss:\\/\\//i, \"https://\").replace(/^ws:\\/\\//i, \"http://\");\n  const strippedRealtime = wsNormalized.replace(/\\/v1\\/realtime(?:\\/calls)?$/i, \"/v1\");\n  const noTrail = strippedRealtime.replace(/\\/+$/, \"\");\n  // Accept either https://api.openai.com or https://api.openai.com/v1\n  return noTrail.endsWith(\"/v1\") ? noTrail : `${noTrail}/v1`;\n}\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n  ssl: { rejectUnauthorized: false },\n});\n\nfunction firstName(full: string) {\n  const s = String(full || \"\").trim();\n  return s.split(/\\s+/)[0] || s || \"Rep\";\n}\n\nfunction userMsg(text: string) {\n  return { role: \"user\", content: text };\n}\n\nfunction toolOutput(callId: string, output: any) {\n  return { type: \"function_call_output\", call_id: callId, output: typeof output === \"string\" ? output : JSON.stringify(output) };\n}\n\nfunction cleanText(v: any) {\n  if (v == null) return \"\";\n  const s = String(v).trim();\n  return s;\n}\n\nfunction extractAssistantText(output: any[]) {\n  const chunks: string[] = [];\n  for (const item of output || []) {\n    if (item?.type === \"message\" && item?.role === \"assistant\") {\n      for (const c of item?.content || []) {\n        if (c?.type === \"output_text\" && typeof c.text === \"string\") chunks.push(c.text);\n      }\n    }\n  }\n  return chunks.join(\"\\n\").trim();\n}\n\nasync function fetchHealthScore(orgId: number, opportunityId: number) {\n  try {\n    const { rows } = await pool.query(\n      `SELECT health_score FROM opportunities WHERE org_id = $1 AND id = $2 LIMIT 1`,\n      [orgId, opportunityId]\n    );\n    const n = Number(rows?.[0]?.health_score);\n    return Number.isFinite(n) ? n : 0;\n  } catch {\n    return 0;\n  }\n}\n\nexport async function POST(req: Request) {\n  try {\n    const baseUrl = resolveBaseUrl();\n    const apiKey = process.env.MODEL_API_KEY || process.env.OPENAI_API_KEY;\n    const model = process.env.MODEL_NAME;\n    if (!baseUrl)\n      return NextResponse.json(\n        { ok: false, error: \"Missing OPENAI_BASE_URL (or MODEL_API_URL)\" },\n        { status: 500 }\n      );\n    if (!apiKey) return NextResponse.json({ ok: false, error: \"Missing MODEL_API_KEY\" }, { status: 500 });\n    if (!model) return NextResponse.json({ ok: false, error: \"Missing MODEL_NAME\" }, { status: 500 });\n\n    const body = await req.json().catch(() => ({}));\n    const sessionId = String(body?.sessionId || \"\");\n    const text = String(body?.text || \"\").trim();\n    if (!sessionId) return NextResponse.json({ ok: false, error: \"Missing sessionId\" }, { status: 400 });\n    if (!text) return NextResponse.json({ ok: false, error: \"Missing text\" }, { status: 400 });\n\n    const session = sessions.get(sessionId);\n    if (!session) return NextResponse.json({ ok: false, error: \"Invalid session\" }, { status: 400 });\n\n    const tools = buildTools();\n\n    // Build a running input list (user messages + model outputs + tool outputs).\n    const input: any[] = Array.isArray(session.items) ? [...session.items] : [];\n    input.push(userMsg(text));\n\n    const maxLoops = 6; // tool-call loops guard\n    let loop = 0;\n    let lastResponse: any = null;\n\n    while (loop < maxLoops) {\n      loop += 1;\n\n      const deal = session.deals[session.index];\n      const instructions = deal\n        ? buildPrompt(\n            deal,\n            firstName(session.repName),\n            session.deals.length,\n            session.index === 0,\n            session.touched,\n            session.scoreDefs\n          )\n        : \"SYSTEM PROMPT — SALES FORECAST AGENT\\nNo deals available.\";\n\n      const resp = await fetch(`${baseUrl}/responses`, {\n        method: \"POST\",\n        headers: {\n          Authorization: `Bearer ${apiKey}`,\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          model,\n          instructions,\n          tools,\n          tool_choice: \"auto\",\n          input,\n        }),\n      });\n\n      const json = await resp.json().catch(async () => ({ error: { message: await resp.text() } }));\n      if (!resp.ok) {\n        const msg = json?.error?.message || JSON.stringify(json);\n        return NextResponse.json({ ok: false, error: msg }, { status: resp.status });\n      }\n\n      lastResponse = json;\n      const output = Array.isArray(json?.output) ? json.output : [];\n\n      // Append model outputs to running input.\n      for (const item of output) input.push(item);\n\n      const toolCalls = output.filter((it: any) => it?.type === \"function_call\");\n      if (!toolCalls.length) break;\n\n      for (const call of toolCalls) {\n        const name = String(call?.name || \"\");\n        const callId = String(call?.call_id || \"\");\n        let args: any = {};\n        try {\n          args = call?.arguments ? JSON.parse(call.arguments) : {};\n        } catch {\n          args = {};\n        }\n\n        if (name === \"save_deal_data\") {\n          // Normalize camelCase variants\n          if (args.risk_summary == null && args.riskSummary != null) args.risk_summary = args.riskSummary;\n          if (args.next_steps == null && args.nextSteps != null) args.next_steps = args.nextSteps;\n          const wrapRisk = cleanText(args.risk_summary);\n          const wrapNext = cleanText(args.next_steps);\n          const wrapComplete = !!wrapRisk && !!wrapNext;\n\n          // Track touched categories (same logic as existing tool route)\n          for (const key of Object.keys(args || {})) {\n            if (key.endsWith(\"_score\") || key.endsWith(\"_summary\") || key.endsWith(\"_tip\")) {\n              const category = key.replace(/_score$/, \"\").replace(/_summary$/, \"\").replace(/_tip$/, \"\");\n              session.touched.add(category);\n            }\n          }\n\n          const activeDeal = session.deals[session.index];\n          if (!activeDeal) {\n            input.push(toolOutput(callId, { status: \"error\", error: \"No active deal\" }));\n            continue;\n          }\n\n          const result = await handleFunctionCall({\n            toolName: \"save_deal_data\",\n            args: {\n              ...args,\n              org_id: session.orgId,\n              opportunity_id: activeDeal.id,\n              rep_name: session.repName,\n              call_id: `web_turn_${Date.now()}`,\n            },\n            pool,\n          });\n\n          // Keep local deal in sync\n          for (const [k, v] of Object.entries(args || {})) {\n            if (v !== undefined) (activeDeal as any)[k] = v;\n          }\n\n          input.push(toolOutput(callId, { status: \"success\", result }));\n\n          // Record wrap saved for THIS review only when BOTH fields are non-empty.\n          if (wrapComplete) {\n            session.wrapSaved = true;\n          } else if (wrapRisk || wrapNext) {\n            // If the model tried to save wrap fields but missed one, force correction.\n            session.wrapSaved = false;\n            const hs = await fetchHealthScore(session.orgId, activeDeal.id);\n            input.push(\n              userMsg(\n                \"End-of-deal wrap save is incomplete. You MUST save BOTH fields:\\n\" +\n                  \"1) Speak Updated Risk Summary (if not already spoken).\\n\" +\n                  `2) Say EXACTLY: \\\"Your Deal Health Score is ${hs} out of 30.\\\" (do not change this number)\\n` +\n                  \"3) Speak Suggested Next Steps (if not already spoken).\\n\" +\n                  \"4) Call save_deal_data with NON-EMPTY risk_summary AND NON-EMPTY next_steps.\\n\" +\n                  \"5) Then call advance_deal.\\n\" +\n                  \"Do NOT ask questions.\"\n              )\n            );\n          }\n\n          // If deal is complete but wrap not done, force it with the actual health score.\n          const stage = String(activeDeal?.forecast_stage || \"Pipeline\");\n          const isPipeline = stage.includes(\"Pipeline\");\n          const requiredCats = isPipeline\n            ? [\"pain\", \"metrics\", \"champion\", \"competition\", \"budget\"]\n            : [\"pain\", \"metrics\", \"champion\", \"criteria\", \"competition\", \"timing\", \"budget\", \"eb\", \"process\", \"paper\"];\n          const allTouched = requiredCats.every((cat) => session.touched.has(cat));\n          if (allTouched && !session.wrapSaved) {\n            const hs = await fetchHealthScore(session.orgId, activeDeal.id);\n            input.push(\n              userMsg(\n                \"All required categories reviewed. You MUST complete the end-of-deal wrap now:\\n\" +\n                  \"1) Speak 'Updated Risk Summary: <your synthesis>'\\n\" +\n                  `2) Say EXACTLY: \\\"Your Deal Health Score is ${hs} out of 30.\\\" (do not change this number)\\n` +\n                  \"3) Speak 'Suggested Next Steps: <your recommendations>'\\n\" +\n                  \"4) Call save_deal_data with NON-EMPTY risk_summary and next_steps\\n\" +\n                  \"5) Call advance_deal.\\n\" +\n                  \"Do NOT ask questions.\"\n              )\n            );\n          }\n          continue;\n        }\n\n        if (name === \"advance_deal\") {\n          // Block advance until wrap save has been recorded for this review.\n          if (!session.wrapSaved) {\n            const activeDeal = session.deals[session.index];\n            const hs = activeDeal ? await fetchHealthScore(session.orgId, activeDeal.id) : 0;\n            input.push(toolOutput(callId, { status: \"error\", error: \"end_wrap_not_saved\" }));\n            input.push(\n              userMsg(\n                \"STOP. Before advancing, you MUST complete the end-of-deal wrap and save it:\\n\" +\n                  \"1) Speak Updated Risk Summary.\\n\" +\n                  `2) Say EXACTLY: \\\"Your Deal Health Score is ${hs} out of 30.\\\" (do not change this number)\\n` +\n                  \"3) Speak Suggested Next Steps.\\n\" +\n                  \"4) Call save_deal_data with NON-EMPTY risk_summary AND NON-EMPTY next_steps.\\n\" +\n                  \"5) Then call advance_deal.\\n\" +\n                  \"Do NOT ask questions.\"\n              )\n            );\n            continue;\n          }\n\n          // Advance deal in session (same behavior as existing advance route)\n          session.index += 1;\n          session.touched = new Set<string>();\n          session.items = [];\n          session.wrapSaved = false;\n          input.length = 0; // reset conversation items for next deal\n\n          if (session.index >= session.deals.length) {\n            input.push(toolOutput(callId, { status: \"success\", done: true }));\n            break;\n          }\n\n          input.push(toolOutput(callId, { status: \"success\" }));\n          // Continue loop; next Responses call will use updated instructions and fresh input.\n          continue;\n        }\n\n        // Unknown tool: return no-op\n        input.push(toolOutput(callId, { status: \"success\", ignored: name }));\n      }\n    }\n\n    // Persist updated running items back to session for next turn.\n    session.items = input;\n\n    const assistantText = extractAssistantText(Array.isArray(lastResponse?.output) ? lastResponse.output : []);\n    return NextResponse.json({\n      ok: true,\n      text: assistantText,\n      done: session.index >= session.deals.length,\n    });\n  } catch (e: any) {\n    return NextResponse.json({ ok: false, error: e?.message || String(e) }, { status: 500 });\n  }\n}\n\n"],"names":[],"mappings":"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"}}]
}